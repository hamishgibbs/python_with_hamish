ğŸ‘„ ğŸ‘¶ ğŸ¡ ğŸš ğŸ“‘ â†˜ï¸ ğŸ‘¨ ğŸ—„ â˜‚ ğŸ– ğŸ›¢ ğŸ›ƒ â™£ï¸ ğŸµ ğŸ˜º ğŸ• ğŸ â—¼ï¸ ğŸ‘œ ğŸ“˜ ğŸ‘™ ğŸ”Œ ğŸ ğŸ‡ ğŸˆ¯ï¸ ğŸ”³ ğŸŠ ğŸ” ğŸšŠ ğŸ™„ ğŸ”› ğŸ™€
# Session 1

## Requirements

A text file: `whatever_name.py`.
A Python installation: `python`.

## Setup

Play around with the terminal:

`cd`: go somewhere.
`cd ~`: go home.
`cd ../`: go one level up from where you are.
`cat`: Print a file to the terminal.
`cp`: Copy a file to another place.
`mv`: Move a file to another place.
`rm`: Delete a file.
`rm -r`: Delete a directory and its contents.

Check that python is installed:

`python --version`

## Exercises

1. Print something to the terminal from your python file.

2. Define a function that does something.

3. Call your function and print the result.

4. Write a function that calls a function.

5. Write a function that calls a function that calls a function.

6. Break these new functions into multiple files.

7. Import these functions into the original file.

8. Write an "import guard" (using `"__name__ == '__main__'"`).

## Additional

6. Refactor a common workflow into functions.

10. Refactor your workflow to extend it to multiple inputs.

## Tips

Think of the command line as a file explorer.

The goal of modular code is to remember what a section of code does 6 months from now.

There are no right answers, just better or worse. You will have to find what coding practices work best for you.

There are very many programming languages, tools, frameworks, packages, package managers, development environments. Don't worry too much - the basics of programming are always the same. That's why we are using a text file and a python installation.
